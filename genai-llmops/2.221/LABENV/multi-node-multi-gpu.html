<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Deploying a Model with vLLM on a multiple node with multiple GPUs :: LLM Operations Optimization and Inference</title>
    <meta name="generator" content="Antora 3.1.3">
    <link rel="stylesheet" href="../../../_/css/site.css">
    <script>var uiRootPath = '../../../_'</script>
  </head>
  <body class="article">
<header class="header">
  <nav class="navbar">
    <div class="navbar-brand">
      <a class="navbar-item" href="https://www.redhat.com" target="_blank"><img src="../../../_/img/redhat-logo.png" height="40px" alt="Red Hat"></a>
      <a class="navbar-item" style="font-size: 24px; color: white" href="../../..">LLM Operations Optimization and Inference</a>
      <button class="navbar-burger" data-target="topbar-nav">
        <span></span>
        <span></span>
        <span></span>
      </button>
    </div>
    <div id="topbar-nav" class="navbar-menu">
      <div class="navbar-end">
        <a class="navbar-item" href="https://github.com/RedHatQuickCourses/REPLACEREPONAME/issues" target="_blank">Report Issues</a>
      </div>
    </div>
  </nav>
</header>
<div class="body">
<div class="nav-container" data-component="genai-llmops" data-version="2.221">
  <aside class="nav">
    <div class="panels">
<div class="nav-panel-menu is-active" data-panel="menu">
  <nav class="nav-menu">
    <h3 class="title"><a href="../index.html">LLM Operations Optimization and Inference</a></h3>
<ul class="nav-list">
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <a class="nav-link" href="../index.html">LLM Ops: Your Adventure Begins</a>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../chapter1/intro.html">Home</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../chapter1/mission.html">Your Place in the Adventure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../chapter1/index.html">Evaluating System Performance with GuideLLM</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter1/section1.html">Introduction to Performance Benchmarking</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter1/section2.html">Running Your First Benchmark</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter1/section3.html">Interpreting Benchmark Results</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter1/section4.html">Advanced Benchmarking Scenarios</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter1/section5.html">Course Wrap-up</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../chapter2/index.html">Course: Evaluating Model Accuracy with lm-eval-harness</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../chapter2/mission.html">Your Place in the Adventure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../chapter2/index.html">Course: Evaluating Model Accuracy with lm-eval-harness</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter2/section1.html">Setting Up the Trusty AI Environment</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter2/section2.html">Running a Standard Evaluation Job</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter2/section3.html">Interpreting Accuracy Results</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter2/section4.html">Running a Domain-Specific Test</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter2/section5.html">Course Wrap-up</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
  <li class="nav-item" data-depth="0">
<ul class="nav-list">
  <li class="nav-item" data-depth="1">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="#intro.adoc">intro.adoc</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="2">
    <a class="nav-link" href="../chapter3/mission.html">Your Place in the Adventure</a>
  </li>
  <li class="nav-item" data-depth="2">
    <button class="nav-item-toggle"></button>
    <a class="nav-link" href="../chapter3/index.html">Model Quantization with LLM Compressor</a>
<ul class="nav-list">
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter3/section1.html">Module 1: Your First Quantization (W4A16)</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter3/section2.html">Check your work</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter3/section3.html">Module 2: Automating Quantization with Pipelines</a>
  </li>
  <li class="nav-item" data-depth="3">
    <a class="nav-link" href="../chapter3/section4.html">Course Wrap-up</a>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </li>
</ul>
  </nav>
</div>
<div class="nav-panel-explore" data-panel="explore">
  <div class="context">
    <span class="title">LLM Operations Optimization and Inference</span>
    <span class="version">2.221</span>
  </div>
  <ul class="components">
    <li class="component is-current">
      <a class="title" href="../index.html">LLM Operations Optimization and Inference</a>
      <ul class="versions">
        <li class="version is-current is-latest">
          <a href="../index.html">2.221</a>
        </li>
      </ul>
    </li>
  </ul>
</div>
    </div>
  </aside>
</div>
<main class="article">
<div class="toolbar" role="navigation">
<button class="nav-toggle"></button>
  <a href="../index.html" class="home-link"></a>
<nav class="breadcrumbs" aria-label="breadcrumbs">
  <ul>
    <li><a href="../index.html">LLM Operations Optimization and Inference</a></li>
    <li><a href="multi-node-multi-gpu.html">Deploying a Model with vLLM on a multiple node with multiple GPUs</a></li>
  </ul>
</nav>
</div>
  <div class="content">
<aside class="toc sidebar" data-title="Contents" data-levels="2">
  <div class="toc-menu"></div>
</aside>
<article class="doc">
<h1 class="page">Deploying a Model with vLLM on a multiple node with multiple GPUs</h1>
<div id="preamble">
<div class="sectionbody">
<div class="paragraph">
<p>We have successfully deployed vLLM on a single node with multiple GPUs, the natural next step is going to deploy a vLLM instance over multiple nodes with multiple GPUs.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_multi_node_vllm_overview"><a class="anchor" href="#_multi_node_vllm_overview"></a>Multi-node vLLM Overview</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Multi-node vLLM is a powerful tool for deploying larger models that won&#8217;t fit on the GPUs available in a single node.</p>
</div>
<div class="paragraph">
<p>For example, a node with 8x H100 (80Gb vRAM each) has a total of 640Gb of vRAM.  An un-quantized version of Llama 405b requires approximately 900Gb of vRAM just to load the model (not factoring in the KV Cache requirements) so the model must be broken up across multiple nodes.</p>
</div>
<div class="paragraph">
<p>Multi-node vLLM enables us to start multiple pods with a <code>head</code> node and additional <code>worker</code> nodes.  The <code>head</code> will act as the main vLLM server, and both the model and KV Cache will be distributed across the nodes.</p>
</div>
<div class="paragraph">
<p>Multi-node instances do not have all of the same capabilities as a single node instance.  For example, multi-node instances are only available as <code>Standard</code> (aka RawDeployment) and not <code>Advanced</code> (aka Serverless).  Additionally, multi-node instances only support serving models from a ReadWriteMany (RWX) PVC or a ModelCar image.  They do not support serving models directly from an S3 bucket.</p>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_deploying_a_multi_node_vllm_instance"><a class="anchor" href="#_lab_deploying_a_multi_node_vllm_instance"></a>Lab: Deploying a Multi-node vLLM Instance</h2>
<div class="sectionbody">
<div class="paragraph">
<p>In this section we will deploy a multi-node vLLM instance with two nodes, each with two GPUs.</p>
</div>
<div class="paragraph">
<p>For this lab, we will continue to use the <code>vllm</code> namespace.</p>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Multi-node vLLM is a Tech Preview feature and is not supported in the OpenShift AI Dashboard.  For this lab, we will be deploying the vLLM instance using the CLI.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Refer to the official documentation for more information on how to deploy a multi-node vLLM instance: <a href="https://docs.redhat.com/en/documentation/red_hat_openshift_ai_self-managed/2.22/html-single/serving_models/index#deploying-models-using-multiple-gpu-nodes_serving-large-models" class="bare">https://docs.redhat.com/en/documentation/red_hat_openshift_ai_self-managed/2.22/html-single/serving_models/index#deploying-models-using-multiple-gpu-nodes_serving-large-models</a></p>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>To start, we need to process and deploy a template from the <code><code>redhat-ods-applications</code></code> project:</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc process vllm-multinode-runtime-template -n redhat-ods-applications | oc apply -n vllm -f -</code></pre>
</div>
</div>
</li>
</ol>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The OpenShift AI Dashboard provides several out of the box "Serving Runtimes" for different models servers.  These can be found in the "Serving Runtimes" section in the OpenShift AI Dashboard under "Settings" if you are an Admin.  These "Serving Runtimes" are OpenShift Templates similar to the one we use above.  These templates container a copy of a <code>ServingRuntime</code> object and when using the UI to deploy a model the template is processed to create a <code>ServingRuntime</code> object in the namespace.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Processing the template will create a <code>ServingRuntime</code> object in the <code>vllm</code> namespace called <code>vllm-multinode-runtime</code>.  Take a moment and explore the ServingRuntime to see what it contains:</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc get servingruntime vllm-multinode-runtime -n vllm -o yaml</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>As of 2.22 the <code>ServingRuntime</code> object must be named <code>vllm-multinode-runtime</code> in order for the odh-model-controller to automatically setup the Ray TLS certs needed for multi-node deployments.  In newer versions of RHOAI any name can be used for the model server.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>We have already created a ReadWriteMany (RWX) PVC for the model in the <code>vllm</code> namespace and loaded <a href="https://huggingface.co/RedHatAI/Llama-3.3-70B-Instruct-quantized.w4a16">Llama-3.3-70B-Instruct-quantized.w4a16</a> into it.  Take a moment to review the PVC:</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc get pvc llama-model -n vllm
oc describe pvc llama-model -n vllm</code></pre>
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>Multi-node vLLM supports both <code>ReadWriteMany</code> PVCs and ModelCar images for serving.  S3 buckets are not supported for multi-node deployments.</p>
</div>
<div class="paragraph">
<p>ReadWriteOnce PVCs are not supported for multi-node deployments since the PVC must be mounted to both the <code>head</code> and <code>worker</code> pods.</p>
</div>
</td>
</tr>
</table>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>In a real world scenario, you will need to create the PVC and download a copy of the model to the PVC.  The way you copy the model will likely depend on the environment you are working in and what you have access to.</p>
</div>
<div class="paragraph">
<p>If the model is already available on an S3 instance like in our cluster, you may wish to use a Job similar to the one that was already executed in your cluster to download the model to the PVC.  Alternatively, you could create a job that copies the model directly from HuggingFace to the PVC if you have access to HuggingFace from your cluster.  In some cases it may be easier to mount the PVC to a Workbench and copy the model to the PVC from the Workbench.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
<li>
<p>Next, we will need to create the <code>InferenceService</code> object that will be used to serve the model.  Copy the following YAML into a file and create it on the cluster using <code>oc apply</code> or copy and paste it into the OpenShift Web Console using the <code>+</code> button in the top right corner of the screen.</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">apiVersion: serving.kserve.io/v1beta1
kind: InferenceService
metadata:
  annotations:
    serving.kserve.io/autoscalerClass: external
    serving.kserve.io/deploymentMode: RawDeployment # 1
  labels:
    networking.kserve.io/visibility: exposed # 2
  name: vllm-multi-node-llama
  namespace: vllm
spec:
  predictor:
    minReplicas: 1
    model:
      args: # 3
        - --max-model-len=100000
      modelFormat:
        name: vLLM
      name: ""
      resources:
        limits:
          cpu: "8"
          memory: 12Gi
          nvidia.com/gpu: "2"
        requests:
          cpu: "4"
          memory: 8Gi
          nvidia.com/gpu: "2"
      runtime: vllm-multinode-runtime
      storageUri: pvc://llama-model/Llama-3.3-70B-Instruct-quantized.w4a16 # 4
    tolerations:
      - effect: NoSchedule
        key: nvidia.com/gpu
        operator: Exists
    workerSpec:
      containers:
        - name: worker-container
          resources:
            limits:
              cpu: "8"
              memory: 12Gi
              nvidia.com/gpu: "2"
            requests:
              cpu: "4"
              memory: 8Gi
              nvidia.com/gpu: "2"
      pipelineParallelSize: 2 # 5
      tensorParallelSize: 2 # 6
      tolerations:
        - effect: NoSchedule
          key: nvidia.com/gpu
          operator: Exists</code></pre>
</div>
</div>
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Multi-node vLLM is only available as <code>RawDeployment</code> mode and not <code>Serverless</code> mode.</p>
</li>
<li>
<p>The <code>exposed</code> label tells KServe to create a Route to expose the model outside of the cluster.</p>
</li>
<li>
<p>The <code>args</code> section is used to set additional arguments needed to help start the model.  In our case, we are limiting the sizing of the KV Cache to 100,000 tokens to allow it to fit on the GPUs in our multi-node setup.</p>
</li>
<li>
<p>The <code>storageUri</code> section is used to provide details of where our model exists.  In this case our pvc is named <code>llama-model</code> and the folder container the model is <code>Llama-3.3-70B-Instruct-quantized.w4a16</code>.</p>
</li>
<li>
<p>The <code>pipelineParallelSize</code> section is used to set the number worker pods that will be created to serve the model.</p>
</li>
<li>
<p>The <code>tensorParallelSize</code> section is used to define the number of GPUs available to each worker pod.</p>
</li>
</ol>
</div>
</li>
<li>
<p>Once the <code>InferenceService</code> is created, we can see the two new pods that have been created.  The <code>vllm-multi-node-llama-predictor-head-&lt;hash&gt;</code> pod is the <code>head</code> node and the <code>vllm-multi-node-llama-predictor-worker-&lt;hash&gt;</code> pod is the <code>worker</code> node.</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc get pods -n vllm</code></pre>
</div>
</div>
<div class="paragraph">
<p>Alternatively, you can use the <code>watch</code> command or flag to follow the status of the pods.</p>
</div>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">watch oc get pods -n vllm</code></pre>
</div>
</div>
<div class="paragraph">
<p>or</p>
</div>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc get pods -n vllm --watch</code></pre>
</div>
</div>
</li>
<li>
<p>Check the logs of both the <code>head</code> and <code>worker</code> pods.  You should see a <code>ray</code> cluster starting in the <code>head</code> pod followed by some logs from vllm starting up.  In the <code>worker</code> you will see a the <code>ray</code> instance starting and the worker pod will join the cluster.</p>
<div class="paragraph">
<p>Head logs:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/multinode-head-logs.png" alt="Multi-node Head Logs">
</div>
</div>
<div class="paragraph">
<p>Worker logs:</p>
</div>
<div class="imageblock">
<div class="content">
<img src="_images/multinode-worker-logs.png" alt="Multi-node Worker Logs">
</div>
</div>
<div class="admonitionblock note">
<table>
<tr>
<td class="icon">
<i class="fa icon-note" title="Note"></i>
</td>
<td class="content">
<div class="paragraph">
<p>The multi-node vLLM instance uses Ray as part of the backend to manage the communication between the pods.  vLLM is responsible for managing our Ray cluster for us as part of the deployment and it does not use any of OpenShift AI&#8217;s Distributed Compute capabilities with CodeFlare and KubeRay.</p>
</div>
<div class="paragraph">
<p>Additionally, the multi-node vLLM should not be confused with <a href="https://docs.ray.io/en/latest/serve/index.html">Ray Serve</a>, which is a ray based serving framework for predictive models.</p>
</div>
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_lab_testing_the_multi_node_vllm_instance"><a class="anchor" href="#_lab_testing_the_multi_node_vllm_instance"></a>Lab: Testing the Multi-node vLLM Instance</h2>
<div class="sectionbody">
<div class="olist arabic">
<ol class="arabic">
<li>
<p>Once all of our pods have gone to a fully <code>Ready</code> state, we can test the model by sending a request to the <code>head</code> pod&#8217;s endpoint.  We can do this by using the <code>curl</code> command to send a request to the <code>head</code> pod&#8217;s endpoint.  First, we will get the route for the vllm endpoint.</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc get route vllm-multi-node-llama -n vllm -o jsonpath='{.spec.host}'</code></pre>
</div>
</div>
</li>
<li>
<p>Next we will use the route URL to perform a curl request to get the name of the model form the models endpoint.</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">curl https://vllm-multi-node-llama-vllm.{openshift_cluster_ingress_domain}/v1/models</code></pre>
</div>
</div>
</li>
<li>
<p>Next, we can use curl to send a prompt to the model.  We will use the <code>-d</code> option to send a JSON payload to the model.</p>
<div class="listingblock execute">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">curl -X 'POST' 'https://vllm-multi-node-llama-vllm.{openshift_cluster_ingress_domain}/v1/chat/completions' \
  -H 'accept: application/json' \
  -H 'Content-Type: application/json' \
  -d '{
  "model": "vllm-multi-node-llama",
  "messages":[
    {
      "role": "system",
      "content": "You'\''re an helpful assistant."
    },
    {
      "role": "user",
      "content": "Write a function in Python that determines if a number is prime.  Explain your approach.  Follow the PEP 8 style guide."
    }
  ],
  "max_tokens": 100
}'</code></pre>
</div>
</div>
<div class="admonitionblock tip">
<table>
<tr>
<td class="icon">
<i class="fa icon-tip" title="Tip"></i>
</td>
<td class="content">
<div class="paragraph">
<p>If you are working with a model that has a secured endpoint, you can add the <code>Authorization</code> header to the curl request.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">-H "Authorization: Bearer &lt;YOUR_TOKEN&gt;"</code></pre>
</div>
</div>
<div class="paragraph">
<p>You can generate a token through the OpenShift AI Dashboard, or use any user/sevice account token that has view permissions on the <code>InferenceService</code> object.</p>
</div>
<div class="paragraph">
<p>To get your OpenShift user token, you can use the following command:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlightjs highlight"><code class="language-shell hljs" data-lang="shell">oc whoami --show-token</code></pre>
</div>
</div>
</td>
</tr>
</table>
</div>
</li>
</ol>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_conclusion"><a class="anchor" href="#_conclusion"></a>Conclusion</h2>
<div class="sectionbody">
<div class="paragraph">
<p>Congratulations!  You have successfully deployed a model with vLLM on a multi-node with multiple GPUs.</p>
</div>
</div>
</div>
</article>
  </div>
</main>
</div>
<footer class="footer">
  <img src="../../../_/img/rhl-logo-red.png" height="40px" alt="Red Hat"  href="https://redhat.com" >
</footer><script id="site-script" src="../../../_/js/site.js" data-ui-root-path="../../../_"></script>
<script async src="../../../_/js/vendor/highlight.js"></script>
  </body>
</html>
